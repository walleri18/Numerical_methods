#pragma once
#include <vector>

/*
	Этот класс обеспечивает логику работы
	решений уравнений с помощью численных методов.

	В данном классе реализованно два типа численных метода:
	1) Метод Ньютона или метод касательных;
	2) Метод простых итераций.

	Публичные методы предоставляемые этим классом являются
	вызовом выполнения нахождения корня конкретного уравнения
	с помощью одного из численных методов.

	Некоторые закрытые методы нужно переписывать, так как они
	являются функцией уравнения либо его производными.
*/
class SolutionEquation
{
// Данные
private:

	/*
		Границы отрезка на котором ищется корень уравнения
	*/
	// Начало отрезка
	double beginSegment;

	// Конец отрезка
	double endSegment;

	/*
			   Необходимая точность, до которой будут вестись
			   расчёты по поиску корня уравнения на данном
			   отрезке
	*/
	double precision;

	/*
		Вычисляемые приближения для корня
	*/
	// Следующее приближение
	double xNext;

	// Предыдущее приближение
	double xPrev;

	/*
		Количество итераций за которое был найден корень
	*/
	int iteration;

	/*
		Все совершённые итерации
	*/
	std::vector<double> *iterationVector;

// Функциональность
public:

	// Загрузка необходимых данных
	SolutionEquation(double beginSegment, double endSegment,
					 double precision);

	// Освобождение ресурсов
	~SolutionEquation();

	// Выполнение метода Ньютона
	void NewtonMethod();

	// Выполнение метода Простых итераций
	void SimpleIterationMethod();

	// Выполнение метода Половинного деления
	void HalfDivisionMethod();

	// Выполнение метода хорд
	void DichotomyMethod();

private:

	/*
		Общий функционал
	*/
	// Очистка количества итераций
	void clearIteration();

	// Предоставление данных об итерациях
	std::vector<double>* getData() const;

	// Вывод результата
	void show();

	/*
		Необходимый функционал для метода Ньютона
	*/
	// Наша функция (именно её нужно переписывать
	// при новом уравнении)
	double ourFunction(double argument);

	// Первая производная нашей функции (тоже нужно переписывать)
	double firstDerivativeOurFunction(double argument);

	// Вторая производная нашей функции (тоже нужно переписывать)
	double secondDerivativeOurFunction(double argument);

	// Метод проверящий существует ли корень на данном отрезке
	bool isRoot();

	// Поиск начальной точки
	double findStartingPoint();

	// Функция говорящая 

	/*
		Необходимый функционал для метода простых итераций
	*/
	// Наша новая преобразованная функция
	double newOurFunction(double argument);

};

